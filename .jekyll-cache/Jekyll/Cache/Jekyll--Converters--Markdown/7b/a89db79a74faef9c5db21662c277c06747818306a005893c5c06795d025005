I"†ñ<blockquote>
  <p>Word embedding is a dense representation of words in the form of numeric vectors. It can be learned using a variety of language models. The word embedding representation is able to reveal many hidden relationships between words. For example, vector(‚Äúcat‚Äù) - vector(‚Äúkitten‚Äù) is similar to vector(‚Äúdog‚Äù) - vector(‚Äúpuppy‚Äù). This post introduces several models for learning word embedding and how their loss functions are designed for the purpose.</p>
</blockquote>

<!--more-->

<p>Human vocabulary comes in free text. In order to make a machine learning model understand and process the natural language, we need to transform the free-text words into numeric values. One of the simplest transformation approaches is to do a one-hot encoding in which each distinct word stands for one dimension of the resulting vector and a binary value indicates whether the word presents (1) or not (0).</p>

<p>However, one-hot encoding is impractical computationally when dealing with the entire vocabulary, as the representation demands hundreds of thousands of dimensions. Word embedding represents words and phrases in vectors of (non-binary) numeric values with much lower and thus denser dimensions. An intuitive assumption for good word embedding is that they can approximate the similarity between words (i.e., ‚Äúcat‚Äù and ‚Äúkitten‚Äù are similar words, and thus they are expected to be close in the reduced vector space) or disclose hidden semantic relationships (i.e., the relationship between ‚Äúcat‚Äù and ‚Äúkitten‚Äù is an analogy to the one between ‚Äúdog‚Äù and ‚Äúpuppy‚Äù). Contextual information is super useful for learning word meaning and relationship, as similar words may appear in the similar context often.</p>

<ul class="table-of-content" id="markdown-toc">
  <li><a href="#count-based-vector-space-model" id="markdown-toc-count-based-vector-space-model">Count-Based Vector Space Model</a></li>
  <li><a href="#context-based-skip-gram-model" id="markdown-toc-context-based-skip-gram-model">Context-Based: Skip-Gram Model</a></li>
  <li><a href="#context-based-continuous-bag-of-words-cbow" id="markdown-toc-context-based-continuous-bag-of-words-cbow">Context-Based: Continuous Bag-of-Words (CBOW)</a></li>
  <li><a href="#loss-functions" id="markdown-toc-loss-functions">Loss Functions</a>    <ul>
      <li><a href="#full-softmax" id="markdown-toc-full-softmax">Full Softmax</a></li>
      <li><a href="#hierarchical-softmax" id="markdown-toc-hierarchical-softmax">Hierarchical Softmax</a></li>
      <li><a href="#cross-entropy" id="markdown-toc-cross-entropy">Cross Entropy</a></li>
      <li><a href="#noise-contrastive-estimation-nce" id="markdown-toc-noise-contrastive-estimation-nce">Noise Contrastive Estimation (NCE)</a></li>
      <li><a href="#negative-sampling-neg" id="markdown-toc-negative-sampling-neg">Negative Sampling (NEG)</a></li>
    </ul>
  </li>
  <li><a href="#other-tips-for-learning-word-embedding" id="markdown-toc-other-tips-for-learning-word-embedding">Other Tips for Learning Word Embedding</a></li>
  <li><a href="#glove-global-vectors" id="markdown-toc-glove-global-vectors">GloVe: Global Vectors</a></li>
  <li><a href="#examples-word2vec-on-game-of-thrones" id="markdown-toc-examples-word2vec-on-game-of-thrones">Examples: word2vec on ‚ÄúGame of Thrones‚Äù</a></li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
</ul>

<p>There are two main approaches for learning word embedding, both relying on the contextual knowledge.</p>
<ul>
  <li><strong>Count-based</strong>: The first one is unsupervised, based on matrix factorization of a global word co-occurrence matrix. Raw co-occurrence counts do not work well, so we want to do smart things on top.</li>
  <li><strong>Context-based</strong>: The second approach is supervised. Given a local context, we want to design a model to predict the target words and in the meantime, this model learns the efficient word embedding representation.</li>
</ul>

<h2 id="count-based-vector-space-model">Count-Based Vector Space Model</h2>

<p>Count-based vector space models heavily rely on the word frequency and co-occurrence matrix with the assumption that words in the same contexts share similar or related semantic meanings. The models map count-based statistics like co-occurrences between neighboring words down to a small and dense word vectors. PCA, topic models, and neural probabilistic language models are all good examples of this category.</p>

<hr />

<p>Different from the count-based approaches, context-based methods build predictive models that directly target at predicting a word given its neighbors. The dense word vectors are part of the model parameters. The best vector representation of each word is learned during the model training process.</p>

<h2 id="context-based-skip-gram-model">Context-Based: Skip-Gram Model</h2>

<p>Suppose that you have a sliding window of a fixed size moving along a sentence: the word in the middle is the ‚Äútarget‚Äù and those on its left and right within the sliding window are the context words. The skip-gram model (<a href="https://arxiv.org/pdf/1301.3781.pdf">Mikolov et al., 2013</a>) is trained to predict the probabilities of a word being a context word for the given target.</p>

<p>The following example demonstrates multiple pairs of target and context words as training samples, generated by a 5-word window sliding along the sentence.</p>

<blockquote>
  <p>‚ÄúThe man who passes the sentence should swing the sword.‚Äù ‚Äì Ned Stark</p>
</blockquote>

<table class="info">
  <thead>
    <tr>
      <th>Sliding window (size = 2)</th>
      <th>Target word</th>
      <th>Context</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>[The man who]</td>
      <td>the</td>
      <td>man, who</td>
    </tr>
    <tr>
      <td>[The man who passes]</td>
      <td>man</td>
      <td>the, who, passes</td>
    </tr>
    <tr>
      <td>[The man who passes the]</td>
      <td>who</td>
      <td>the, man, passes, the</td>
    </tr>
    <tr>
      <td>[man who passes the sentence]</td>
      <td>passes</td>
      <td>man, who, the, sentence</td>
    </tr>
    <tr>
      <td>‚Ä¶</td>
      <td>‚Ä¶</td>
      <td>‚Ä¶</td>
    </tr>
    <tr>
      <td>[sentence should swing the sword]</td>
      <td>swing</td>
      <td>sentence, should, the, sword</td>
    </tr>
    <tr>
      <td>[should swing the sword]</td>
      <td>the</td>
      <td>should, swing, sword</td>
    </tr>
    <tr>
      <td>[swing the sword]</td>
      <td>sword</td>
      <td>swing, the</td>
    </tr>
  </tbody>
</table>

<p>Each context-target pair is treated as a new observation in the data. For example, the target word ‚Äúswing‚Äù in the above case produces four training samples: (‚Äúswing‚Äù, ‚Äúsentence‚Äù), (‚Äúswing‚Äù, ‚Äúshould‚Äù), (‚Äúswing‚Äù, ‚Äúthe‚Äù), and (‚Äúswing‚Äù, ‚Äúsword‚Äù).</p>

<p style="width: 640px;" class="center"><img src="/assets/images/word2vec-skip-gram.png" alt="Skip-gram Model" /></p>
<p><em>Fig. 1. The skip-gram model. Both the input vector \(\mathbf{x}\) and the output \(\mathbf{y}\) are one-hot encoded word representations. The hidden layer is the word embedding of size \(N\).</em></p>

<p>Given the vocabulary size \(V\), we are about to learn word embedding vectors of size \(N\). The model learns to predict one context word (output) using one target word (input) at a time.</p>

<p>According to Fig. 1,</p>

<ul>
  <li>Both input word \(w_i\) and the output word \(w_j\) are one-hot encoded into binary vectors \(\mathbf{x}\) and \(\mathbf{y}\) of size \(V\).</li>
  <li>First, the multiplication of the binary vector \(\mathbf{x}\) and the word embedding matrix \(W\) of size \(V \times N\) gives us the embedding vector of the input word \(w_i\): the i-th row of the matrix \(W\).</li>
  <li>This newly discovered embedding vector of dimension \(N\) forms the hidden layer.</li>
  <li>The multiplication of the hidden layer and the word context matrix \(W‚Äô\) of size \(N \times W\) produces the output one-hot encoded vector \(\mathbf{y}\).</li>
  <li>The output context matrix \(W‚Äô\) encodes the meanings of words as context, different from the embedding matrix \(W\). NOTE: Despite the name, \(W‚Äô\) is independent of \(W\), not a transpose or inverse or whatsoever.</li>
</ul>

<h2 id="context-based-continuous-bag-of-words-cbow">Context-Based: Continuous Bag-of-Words (CBOW)</h2>

<p>The Continuous Bag-of-Words (CBOW) is another similar model for learning word vectors. It predicts the target word (i.e. ‚Äúswing‚Äù) from source context words (i.e., ‚Äúsentence should the sword‚Äù).</p>

<p style="width: 640px;" class="center"><img src="/assets/images/word2vec-cbow.png" alt="CBOW Model" /></p>
<p><em>Fig. 2. The CBOW model. Word vectors of multiple context words are averaged to get a fixed-length vector as in the hidden layer. Other symbols have the same meanings as in Fig 1.</em></p>

<p>Because there are multiple contextual words, we average their corresponding word vectors, constructed by the multiplication of the input vector and the matrix \(W\). Because the averaging stage smoothes over a lot of the distributional information, some people believe the CBOW model is better for small dataset.</p>

<h2 id="loss-functions">Loss Functions</h2>

<p>Both the skip-gram model and the CBOW model should be trained to minimize a well-designed loss/objective function. There are several loss functions we can incorporate to train these language models. In the following discussion, we will use the skip-gram model as an example to describe how the loss is computed.</p>

<h3 id="full-softmax">Full Softmax</h3>

<p>The skip-gram model defines the embedding vector of every word by the matrix \(W\) and the context vector by the output matrix \(W'\). Given an input word \(w_I\), let us label the corresponding row of \(W\) as vector \(v_{w_I}\) (embedding vector) and its corresponding column of \(W'\) as \(v'_{w_I}\) (context vector). The final output layer applies softmax to compute the probability of predicting the output word \(w_O\) given \(w_I\), and therefore:</p>

\[p(w_O \vert w_I) = \frac{\exp({v'_{w_O}}^{\top} v_{w_I})}{\sum_{i=1}^V \exp({v'_{w_i}}^{\top} v_{w_I})}\]

<p>This is accurate as presented in Fig. 1. However, when \(V\) is extremely large, calculating the denominator by going through all the words for every single sample is computationally impractical. The demand for more efficient conditional probability estimation leads to the new methods like <em>hierarchical softmax</em>.</p>

<h3 id="hierarchical-softmax">Hierarchical Softmax</h3>

<p>Morin and Bengio (<a href="https://www.iro.umontreal.ca/~lisa/pointeurs/hierarchical-nnlm-aistats05.pdf">2005</a>) proposed hierarchical softmax to make the sum calculation faster with the help of a binary tree structure. The hierarchical softmax encodes the language model‚Äôs output softmax layer into a tree hierarchy, where each leaf is one word and each internal node stands for relative probabilities of the children nodes.</p>

<p style="width: 420px;" class="center"><img src="/assets/images/word2vec-hierarchical-softmax.png" alt="Hierarchical Softmax" /></p>
<p><em>Fig. 3. An illustration of the hierarchical softmax binary tree. The leaf nodes in white are words in the vocabulary. The gray inner nodes carry information on the probabilities of reaching its child nodes. One path starting from the root to the leaf \(w_i\). \(n(w_i, j)\) denotes the j-th node on this path. (Image source: <a href="https://arxiv.org/pdf/1411.2738.pdf">word2vec Parameter Learning Explained</a>)</em></p>

<p>Each word \(w_i\) has a unique path from the root down to its corresponding leaf. The probability of picking this word is equivalent to the probability of taking this path from the root down through the tree branches. Since we know the embedding vector \(v_n\) of the internal node \(n\), the probability of getting the word can be computed by the product of taking left or right turn at every internal node stop.</p>

<p>According to Fig. 3, the probability of one node is (\(\sigma\) is the sigmoid function):</p>

\[\begin{align}
p(\text{turn right} \to \dots w_I \vert n) &amp;= \sigma({v'_n}^{\top} v_{w_I})\\
p(\text{turn left } \to \dots w_I \vert n) &amp;= 1 - p(\text{turn right} \vert n) = \sigma(-{v'_n}^{\top} v_{w_I})
\end{align}\]

<p>The final probability of getting a context word \(w_O\) given an input word \(w_I\) is:</p>

\[p(w_O \vert w_I) = \prod_{k=1}^{L(w_O)} \sigma(\mathbb{I}_{\text{turn}}(n(w_O, k), n(w_O, k+1)) \cdot {v'_{n(w_O, k)}}^{\top} v_{w_I})\]

<p>where \(L(w_O)\) is the depth of the path leading to the word \(w_O\) and \(\mathbb{I}_{\text{turn}}\) is a specially indicator function which returns 1 if \(n(w_O, k+1)\) is the left child of \(n(w_O, k)\) otherwise -1. The internal nodes‚Äô embeddings are learned during the model training. The tree structure helps greatly reduce the complexity of the denominator estimation from O(V) (vocabulary size) to O(log V) (the depth of the tree) at the training time. However, at the prediction time, we still to compute the probability of every word and pick the best, as we don‚Äôt know which leaf to reach for in advance.</p>

<p>A good tree structure is crucial to the model performance. Several handy principles are: group words by frequency like what is implemented by Huffman tree for simple speedup; group similar words into same or close branches (i.e. use predefined word clusters, WordNet).</p>

<!-- Morin and Bengio use the synsets in WordNet as clusters for the tree. Mnih and Hinton learn the tree structure with a clustering algorithm that recursively partitions the words in two clusters. -->

<h3 id="cross-entropy">Cross Entropy</h3>

<p>Another approach completely steers away from the softmax framework. Instead, the loss function measures the cross entropy between the predicted probabilities \(p\) and the true binary labels \(\mathbf{y}\).</p>

<p>First, let‚Äôs recall that the cross entropy between two distributions \(p\) and \(q\) is measured as \(H(p, q) = -\sum_x p(x) \log q(x)\). In our case, the true label \(y_i\) is 1 only when \(w_i\) is the output word; \(y_j\) is 0 otherwise. The loss function \(\mathcal{L}_\theta\) of the model with parameter config \(\theta\) aims to minimize the cross entropy between the prediction and the ground truth, as lower cross entropy indicates high similarity between two distributions.</p>

\[\mathcal{L}_\theta = - \sum_{i=1}^V y_i \log p(w_i | w_I) = - \log p(w_O \vert w_I)\]

<p>Recall that,</p>

\[p(w_O \vert w_I) = \frac{\exp({v'_{w_O}}^{\top} v_{w_I})}{\sum_{i=1}^V \exp({v'_{w_i}}^{\top} v_{w_I})}\]

<p>Therefore,</p>

\[\mathcal{L}_{\theta} 
= - \log \frac{\exp({v'_{w_O}}^{\top}{v_{w_I}})}{\sum_{i=1}^V \exp({v'_{w_i}}^{\top}{v_{w_I} })}
= - {v'_{w_O}}^{\top}{v_{w_I} } + \log \sum_{i=1}^V \exp({v'_{w_i} }^{\top}{v_{w_I}})\]

<p>To start training the model using back-propagation with SGD, we need to compute the gradient of the loss function. For simplicity, let‚Äôs label \(z_{IO} = {v'_{w_O}}^{\top}{v_{w_I}}\).</p>

\[\begin{align}
\nabla_\theta \mathcal{L}_{\theta}
&amp;= \nabla_\theta\big( - z_{IO} + \log \sum_{i=1}^V e^{z_{Ii}} \big) \\ 
&amp;= - \nabla_\theta z_{IO} + \nabla_\theta \big( \log \sum_{i=1}^V e^{z_{Ii}} \big) \\
&amp;= - \nabla_\theta z_{IO} + \frac{1}{\sum_{i=1}^V e^{z_{Ii}}} \sum_{i=1}^V e^{z_{Ii}} \nabla_\theta z_{Ii} \\
&amp;= - \nabla_\theta z_{IO} + \sum_{i=1}^V \frac{e^{z_{Ii}}}{\sum_{i=1}^V e^{z_{Ii}}} \nabla_\theta z_{Ii} \\
&amp;= - \nabla_\theta z_{IO} + \sum_{i=1}^V p(w_i \vert w_I) \nabla_\theta z_{Ii} \\
&amp;= - \nabla_\theta z_{IO} + \mathbb{E}_{w_i \sim Q(\tilde{w})} \nabla_\theta z_{Ii}
\end{align}\]

<p>where \(Q(\tilde{w})\) is the distribution of noise samples.</p>

<p>According to the formula above, the correct output word has a positive reinforcement according to the first term (the larger \(\nabla_\theta z_{IO}\) the better loss we have), while other words have a negative impact as captured by the second term.</p>

<p>How to estimate \(\mathbb{E}_{w_i \sim Q(\tilde{w})} \nabla_\theta {v'_{w_i}}^{\top}{v_{w_I}}\) with a sample set of noise words rather than scanning through the entire vocabulary is the key of using cross-entropy-based sampling approach.</p>

<h3 id="noise-contrastive-estimation-nce">Noise Contrastive Estimation (NCE)</h3>

<p>The Noise Contrastive Estimation (NCE) metric intends to differentiate the target word from noise samples using a logistic regression classifier (<a href="http://proceedings.mlr.press/v9/gutmann10a/gutmann10a.pdf">Gutmann and Hyv√§rinen, 2010</a>).</p>

<p>Given an input word \(w_I\), the correct output word is known as \(w\). In the meantime, we sample \(N\) other words from the noise sample distribution \(Q\), denoted as \(\tilde{w}_1
, \tilde{w}_2, \dots, \tilde{w}_N \sim Q\). Let‚Äôs label the decision of the binary classifier as \(d\) and \(d\) can only take a binary value.</p>

\[\mathcal{L}_\theta = - [ \log p(d=1 \vert w, w_I) + \sum_{\substack{i=1 \\ \tilde{w}_i \sim Q}}^N \log p(d=0|\tilde{w}_i, w_I) ]\]

<p>When \(N\) is big enough, according to <a href="https://en.wikipedia.org/wiki/Law_of_large_numbers">the Law of large numbers</a>,</p>

\[\mathcal{L}_\theta = - [ \log p(d=1 \vert w, w_I) +  N\mathbb{E}_{\tilde{w}_i \sim Q} \log p(d=0|\tilde{w}_i, w_I)]\]

<p>To compute the probability \(p(d=1 \vert w, w_I)\), we can start with the joint probability \(p(d, w \vert w_I)\). Among \(w, \tilde{w}_1, \tilde{w}_2, \dots, \tilde{w}_N\), we have 1 out of (N+1) chance to pick the true word \(w\), which is sampled from the conditional probability \(p(w \vert w_I)\); meanwhile, we have N out of (N+1) chances to pick a noise word, each sampled from \(q(\tilde{w}) \sim Q\). Thus,</p>

\[p(d, w | w_I) = 
  \begin{cases}
  \frac{1}{N+1} p(w \vert w_I) &amp; \text{if } d=1 \\
  \frac{N}{N+1} q(\tilde{w}) &amp; \text{if } d=0
  \end{cases}\]

<p>Then we can figure out \(p(d=1 \vert w, w_I)\) and \(p(d=0 \vert w, w_I)\):</p>

\[\begin{align}
p(d=1 \vert w, w_I) 
&amp;= \frac{p(d=1, w \vert w_I)}{p(d=1, w \vert w_I) + p(d=0, w \vert w_I)}
&amp;= \frac{p(w \vert w_I)}{p(w \vert w_I) + Nq(\tilde{w})}
\end{align}\]

\[\begin{align}
p(d=0 \vert w, w_I) 
&amp;= \frac{p(d=0, w \vert w_I)}{p(d=1, w \vert w_I) + p(d=0, w \vert w_I)}
&amp;= \frac{Nq(\tilde{w})}{p(w \vert w_I) + Nq(\tilde{w})}
\end{align}\]

<p>Finally the loss function of NCE‚Äôs binary classifier becomes:</p>

\[\begin{align}
\mathcal{L}_\theta 
&amp; = - [ \log p(d=1 \vert w, w_I) +  \sum_{\substack{i=1 \\ \tilde{w}_i \sim Q}}^N \log p(d=0|\tilde{w}_i, w_I)] \\
&amp; = - [ \log \frac{p(w \vert w_I)}{p(w \vert w_I) + Nq(\tilde{w})} +  \sum_{\substack{i=1 \\ \tilde{w}_i \sim Q}}^N \log \frac{Nq(\tilde{w}_i)}{p(w \vert w_I) + Nq(\tilde{w}_i)}]
\end{align}\]

<p>However, \(p(w \vert w_I)\) still involves summing up the entire vocabulary in the denominator. Let‚Äôs label the denominator as a partition function of the input word, \(Z(w_I)\). A common assumption is \(Z(w) \approx 1\) given that we expect the softmax output layer to be normalized (<a href="https://www.cs.toronto.edu/~amnih/papers/ncelm.pdf">Minh and Teh, 2012</a>). Then the loss function is simplified to:</p>

\[\mathcal{L}_\theta = - [ \log \frac{\exp({v'_w}^{\top}{v_{w_I}})}{\exp({v'_w}^{\top}{v_{w_I}}) + Nq(\tilde{w})} +  \sum_{\substack{i=1 \\ \tilde{w}_i \sim Q}}^N \log \frac{Nq(\tilde{w}_i)}{\exp({v'_w}^{\top}{v_{w_I}}) + Nq(\tilde{w}_i)}]\]

<p>The noise distribution \(Q\) is a tunable parameter and we would like to design it in a way so that:</p>
<ul>
  <li>intuitively it should be very similar to the real data distribution; and</li>
  <li>it should be easy to sample from.</li>
</ul>

<p>For example, the sampleing implementation (<a href="https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/candidate_sampling_ops.py#L83">log_uniform_candidate_sampler</a>) of NCE loss in tensorflow assumes that such noise samples follow a log-uniform distribution, also known as <a href="https://en.wikipedia.org/wiki/Zipf%27s_law">Zipfian‚Äôs law</a>. The probability of a given word in logarithm is expected to be reversely proportional to its rank, while high-frequency words are assigned with lower ranks. In this case, \(q(\tilde{w}) = \frac{1}{ \log V}(\log (r_{\tilde{w}} + 1) - \log r_{\tilde{w}})\), where \(r_{\tilde{w}} \in [1, V]\) is the rank of a word by frequency in descending order.</p>

<h3 id="negative-sampling-neg">Negative Sampling (NEG)</h3>

<p>The Negative Sampling (NEG) proposed by Mikolov et al. (<a href="https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf">2013</a>) is a simplified variation of NCE loss. It is especially famous for training Google‚Äôs <a href="https://code.google.com/archive/p/word2vec/">word2vec</a> project. Different from NCE Loss which attempts to approximately maximize the log probability of the softmax output, negative sampling did further simplification because it focuses on learning high-quality word embedding rather than modeling the word distribution in natural language.</p>

<p>NEG approximates the binary classifier‚Äôs output with sigmoid functions as follows:</p>

\[\begin{align}
p(d=1 \vert w_, w_I) &amp;= \sigma({v'_{w}}^\top v_{w_I}) \\
p(d=0 \vert w, w_I) &amp;= 1 - \sigma({v'_{w}}^\top v_{w_I}) = \sigma(-{v'_{w}}^\top v_{w_I})
\end{align}\]

<p>The final NCE loss function looks like:</p>

\[\mathcal{L}_\theta = - [ \log \sigma({v'_{w}}^\top v_{w_I}) +  \sum_{\substack{i=1 \\ \tilde{w}_i \sim Q}}^N \log \sigma(-{v'_{\tilde{w}_i}}^\top v_{w_I})]\]

<h2 id="other-tips-for-learning-word-embedding">Other Tips for Learning Word Embedding</h2>

<p>Mikolov et al. (<a href="https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf">2013</a>) suggested several helpful practices that could result in good word embedding learning outcomes.</p>

<ul>
  <li>
    <p><strong>Soft sliding window</strong>. When pairing the words within the sliding window, we could assign less weight to more distant words. One heuristic is ‚Äî given a maximum window size parameter defined, \(s_{\text{max}}\), the actual window size is randomly sampled between 1 and \(s_{\text{max}}\) for every training sample. Thus, each context word has the probability of 1/(its distance to the target word) being observed, while the adjacent words are always observed.</p>
  </li>
  <li>
    <p><strong>Subsampling frequent words</strong>. Extremely frequent words might be too general to differentiate the context (i.e. think about stopwords). While on the other hand, rare words are more likely to carry distinct information. To balance the frequent and rare words, Mikolov et al. proposed to discard words \(w\) with probability \(1-\sqrt{t/f(w)}\) during sampling. Here \(f(w)\) is the word frequency and \(t\) is an adjustable threshold.</p>
  </li>
  <li>
    <p><strong>Learning phrases first</strong>. A phrase often stands as a conceptual unit, rather than a simple composition of individual words. For example, we cannot really tell ‚ÄúNew York‚Äù is a city name even we know the meanings of ‚Äúnew‚Äù and ‚Äúyork‚Äù. Learning such phrases first and treating them as word units before training the word embedding model improves the outcome quality. A simple data-driven approach is based on unigram and bigram counts: \(s_{\text{phrase}} = \frac{C(w_i w_j) - \delta}{ C(w_i)C(w_j)}\), where \(C(.)\) is simple count of an unigram \(w_i\) or bigram \(w_i w_j\) and \(\delta\) is a discounting threshold to prevent super infrequent words and phrases. Higher scores indicate higher chances of being phrases. To form phrases longer than two words, we can scan the vocabulary multiple times with decreasing score cutoff values.</p>
  </li>
</ul>

<h2 id="glove-global-vectors">GloVe: Global Vectors</h2>

<p>The Global Vector (GloVe) model proposed by Pennington et al. (<a href="http://www.aclweb.org/anthology/D14-1162">2014</a>) aims to combine the count-based matrix factorization and the context-based skip-gram model together.</p>

<p>We all know the counts and co-occurrences can reveal the meanings of words. To distinguish from \(p(w_O \vert w_I)\) in the context of a word embedding word, we would like to define the co-ocurrence probability as:</p>

\[p_{\text{co}}(w_k \vert w_i) = \frac{C(w_i, w_k)}{C(w_i)}\]

<p>\(C(w_i, w_k)\) counts the co-occurrence between words \(w_i\) and \(w_k\).</p>

<p>Say, we have two words, \(w_i\)=‚Äùice‚Äù and \(w_j\)=‚Äùsteam‚Äù. The third word \(\tilde{w}_k\)=‚Äùsolid‚Äù is related to ‚Äúice‚Äù but not ‚Äústeam‚Äù, and thus we expect \(p_{\text{co}}(\tilde{w}_k \vert w_i)\) to be much larger than \(p_{\text{co}}(\tilde{w}_k \vert w_j)\) and therefore \(\frac{p_{\text{co}}(\tilde{w}_k \vert w_i)}{p_{\text{co}}(\tilde{w}_k \vert w_j)}\) to be very large. If the third word \(\tilde{w}_k\) = ‚Äúwater‚Äù is related to both or \(\tilde{w}_k\) = ‚Äúfashion‚Äù is unrelated to either of them, \(\frac{p_{\text{co}}(\tilde{w}_k \vert w_i)}{p_{\text{co}}(\tilde{w}_k \vert w_j)}\) is expected to be close to one.</p>

<p>The intuition here is that the word meanings are captured by the ratios of co-occurrence probabilities rather than the probabilities themselves. The global vector models the relationship between two words regarding to the third context word as:</p>

\[F(w_i, w_j, \tilde{w}_k) = \frac{p_{\text{co}}(\tilde{w}_k \vert w_i)}{p_{\text{co}}(\tilde{w}_k \vert w_j)}\]

<p>Further, since the goal is to learn meaningful word vectors, \(F\) is designed to be a function of the linear difference between two words \(w_i - w_j\):</p>

\[F((w_i - w_j)^\top \tilde{w}_k) = \frac{p_{\text{co}}(\tilde{w}_k \vert w_i)}{p_{\text{co}}(\tilde{w}_k \vert w_j)}\]

<p>With the consideration of \(F\) being symmetric between target words and context words, the final solution is to model \(F\) as an <strong>exponential</strong> function. Please read the original paper (<a href="http://www.aclweb.org/anthology/D14-1162">Pennington et al., 2014</a>) for more details of the equations.</p>

\[\begin{align}
F({w_i}^\top \tilde{w}_k) &amp;= \exp({w_i}^\top \tilde{w}_k) = p_{\text{co}}(\tilde{w}_k \vert w_i) \\
F((w_i - w_j)^\top \tilde{w}_k) &amp;= \exp((w_i - w_j)^\top \tilde{w}_k) = \frac{\exp(w_i^\top \tilde{w}_k)}{\exp(w_j^\top \tilde{w}_k)} = \frac{p_{\text{co}}(\tilde{w}_k \vert w_i)}{p_{\text{co}}(\tilde{w}_k \vert w_j)}
\end{align}\]

<p>Finally,</p>

\[{w_i}^\top \tilde{w}_k = \log p_{\text{co}}(\tilde{w}_k \vert w_i) = \log \frac{C(w_i, \tilde{w})}{C(w_i)} = \log C(w_i, \tilde{w}) - \log C(w_i)\]

<p>Since the second term \(-\log C(w_i)\) is independent of \(k\), we can add bias term \(b_i\) for \(w_i\) to capture \(-\log C(w_i)\). To keep the symmetric form, we also add in a bias \(\tilde{b}_k\) for \(\tilde{w}_k\).</p>

\[\log C(w_i, \tilde{w}) = {w_i}^\top \tilde{w}_k + b_i + \tilde{b}_k\]

<p>The loss function for the GloVe model is designed to preserve the above formula by minimizing the sum of the squared errors:</p>

\[\mathcal{L}_\theta = \sum_{i=1, j=1}^V f(C(w_i,w_j)) ({w_i}^\top \tilde{w} + b_i + \tilde{b}_k - \log C(w_i, \tilde{w}))^2\]

<p>The weighting schema \(f(c)\) is a function of the co-occurrence of \(w_i\) and \(w_j\) and it is an adjustable model configuration. It should be close to zero as \(c \to 0\); should be non-decreasing as higher co-occurrence should have more impact; should saturate when \(c\) become extremely large. The paper proposed the following weighting function.</p>

\[f(c) = 
  \begin{cases}
  (\frac{c}{c_{\max}})^\alpha &amp; \text{if } c &lt; c_{\max} \text{, } c_{\max} \text{ is adjustable.} \\
  1 &amp; \text{if } \text{otherwise}
  \end{cases}\]

<h2 id="examples-word2vec-on-game-of-thrones">Examples: word2vec on ‚ÄúGame of Thrones‚Äù</h2>

<p>After reviewing all the theoretical knowledge above, let‚Äôs try a little experiment in word embedding extracted from <a href="/assets/data/a_song_of_ice_and_fire.zip">the Games of Thrones corpus</a>. The process is super straightforward using <a href="https://radimrehurek.com/gensim/models/word2vec.html">gensim</a>.</p>

<p><strong>Step 1: Extract words</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">stopwords</span>
<span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">sent_tokenize</span>

<span class="n">STOP_WORDS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">stopwords</span><span class="p">.</span><span class="n">words</span><span class="p">(</span><span class="s">'english'</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">get_words</span><span class="p">(</span><span class="n">txt</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">STOP_WORDS</span><span class="p">,</span> 
        <span class="n">re</span><span class="p">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s">'\b(\w+)\b'</span><span class="p">,</span> <span class="n">txt</span><span class="p">)</span>
    <span class="p">)</span>

<span class="k">def</span> <span class="nf">parse_sentence_words</span><span class="p">(</span><span class="n">input_file_names</span><span class="p">):</span>
   <span class="s">"""Returns a list of a list of words. Each sublist is a sentence."""</span>
    <span class="n">sentence_words</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">file_name</span> <span class="ow">in</span> <span class="n">input_file_names</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">strip</span><span class="p">().</span><span class="n">lower</span><span class="p">()</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="s">'unicode_escape'</span><span class="p">).</span><span class="n">encode</span><span class="p">(</span><span class="s">'ascii'</span><span class="p">,</span><span class="s">'ignore'</span><span class="p">)</span>
            <span class="n">sent_words</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">get_words</span><span class="p">,</span> <span class="n">sent_tokenize</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
            <span class="n">sent_words</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">sw</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">sw</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sent_words</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sent_words</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sentence_words</span> <span class="o">+=</span> <span class="n">sent_words</span>
    <span class="k">return</span> <span class="n">sentence_words</span>

<span class="c1"># You would see five .txt files after unzip 'a_song_of_ice_and_fire.zip'
</span><span class="n">input_file_names</span> <span class="o">=</span> <span class="p">[</span><span class="s">"001ssb.txt"</span><span class="p">,</span> <span class="s">"002ssb.txt"</span><span class="p">,</span> <span class="s">"003ssb.txt"</span><span class="p">,</span> 
                    <span class="s">"004ssb.txt"</span><span class="p">,</span> <span class="s">"005ssb.txt"</span><span class="p">]</span>
<span class="n">GOT_SENTENCE_WORDS</span><span class="o">=</span> <span class="n">parse_sentence_words</span><span class="p">(</span><span class="n">input_file_names</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Step 2: Feed a word2vec model</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">gensim.models</span> <span class="kn">import</span> <span class="n">Word2Vec</span>

<span class="c1"># size: the dimensionality of the embedding vectors.
# window: the maximum distance between the current and predicted word within a sentence.
</span><span class="n">model</span> <span class="o">=</span> <span class="n">Word2Vec</span><span class="p">(</span><span class="n">GOT_SENTENCE_WORDS</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">model</span><span class="p">.</span><span class="n">wv</span><span class="p">.</span><span class="n">save_word2vec_format</span><span class="p">(</span><span class="s">"got_word2vec.txt"</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Step 3: Check the results</strong></p>

<p>In the GoT word embedding space, the top similar words to ‚Äúking‚Äù and ‚Äúqueen‚Äù are:</p>

<table class="info">
  <thead>
    <tr>
      <th><code class="language-plaintext highlighter-rouge">model.most_similar('king', topn=10)</code><br /> (word, similarity with ‚Äòking‚Äô)</th>
      <th><code class="language-plaintext highlighter-rouge">model.most_similar('queen', topn=10)</code><br /> (word, similarity with ‚Äòqueen‚Äô)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>(‚Äòkings‚Äô, 0.897245)</td>
      <td>(‚Äòcersei‚Äô, 0.942618)</td>
    </tr>
    <tr>
      <td>(‚Äòbaratheon‚Äô, 0.809675)</td>
      <td>(‚Äòjoffrey‚Äô, 0.933756)</td>
    </tr>
    <tr>
      <td>(‚Äòson‚Äô, 0.763614)</td>
      <td>(‚Äòmargaery‚Äô, 0.931099)</td>
    </tr>
    <tr>
      <td>(‚Äòrobert‚Äô, 0.708522)</td>
      <td>(‚Äòsister‚Äô, 0.928902)</td>
    </tr>
    <tr>
      <td>(‚Äòlords‚Äô, 0.698684)</td>
      <td>(‚Äòprince‚Äô, 0.927364)</td>
    </tr>
    <tr>
      <td>(‚Äòjoffrey‚Äô, 0.696455)</td>
      <td>(‚Äòuncle‚Äô, 0.922507)</td>
    </tr>
    <tr>
      <td>(‚Äòprince‚Äô, 0.695699)</td>
      <td>(‚Äòvarys‚Äô, 0.918421)</td>
    </tr>
    <tr>
      <td>(‚Äòbrother‚Äô, 0.685239)</td>
      <td>(‚Äòned‚Äô, 0.917492)</td>
    </tr>
    <tr>
      <td>(‚Äòaerys‚Äô, 0.684527)</td>
      <td>(‚Äòmelisandre‚Äô, 0.915403)</td>
    </tr>
    <tr>
      <td>(‚Äòstannis‚Äô, 0.682932)</td>
      <td>(‚Äòrobb‚Äô, 0.915272)</td>
    </tr>
  </tbody>
</table>

<hr />

<p><em>If you notice mistakes and errors in this post, don‚Äôt hesitate to contact me at [lilian dot wengweng at gmail dot com] and I would be super happy to correct them right away!</em></p>

<p>See you in the next post :D</p>

<h2 id="references">References</h2>

<p>[1] Tensorflow Tutorial <a href="https://www.tensorflow.org/tutorials/word2vec">Vector Representations of Words</a>.</p>

<p>[2] <a href="http://mccormickml.com/2016/04/19/word2vec-tutorial-the-skip-gram-model/">‚ÄúWord2Vec Tutorial - The Skip-Gram Model‚Äù</a> by Chris McCormick.</p>

<p>[3] <a href="http://ruder.io/word-embeddings-softmax/">‚ÄúOn word embeddings - Part 2: Approximating the Softmax‚Äù</a> by Sebastian Ruder.</p>

<p>[4] Xin Rong. <a href="https://arxiv.org/pdf/1411.2738.pdf">word2vec Parameter Learning Explained</a></p>

<p>[5] Mikolov, Tomas, Kai Chen, Greg Corrado, and Jeffrey Dean. <a href="https://arxiv.org/pdf/1301.3781.pdf">‚ÄúEfficient estimation of word representations in vector space.‚Äù</a> arXiv preprint arXiv:1301.3781 (2013).</p>

<p>[6] Frederic Morin and Yoshua Bengio. <a href="https://www.iro.umontreal.ca/~lisa/pointeurs/hierarchical-nnlm-aistats05.pdf">‚ÄúHierarchical Probabilistic Neural Network Language Model.‚Äù</a> Aistats. Vol. 5. 2005.</p>

<p>[7] Michael Gutmann and Aapo Hyv√§rinen. <a href="http://proceedings.mlr.press/v9/gutmann10a/gutmann10a.pdf">‚ÄúNoise-contrastive estimation: A new estimation principle for unnormalized statistical models.‚Äù</a> Proc. Intl. Conf. on Artificial Intelligence and Statistics. 2010.</p>

<p>[8] Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg Corrado, and Jeffrey Dean. <a href="https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf">‚ÄúDistributed representations of words and phrases and their compositionality.‚Äù</a> Advances in neural information processing systems. 2013.</p>

<p>[9] Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey Dean. <a href="https://arxiv.org/pdf/1301.3781.pdf">‚ÄúEfficient estimation of word representations in vector space.‚Äù</a> arXiv preprint arXiv:1301.3781 (2013).</p>

<p>[10] Marco Baroni, Georgiana Dinu, and Germ√°n Kruszewski. <a href="http://anthology.aclweb.org/P/P14/P14-1023.pdf">‚ÄúDon‚Äôt count, predict! A systematic comparison of context-counting vs. context-predicting semantic vectors.‚Äù</a> ACL (1). 2014.</p>

<p>[11] Jeffrey Pennington, Richard Socher, and Christopher Manning. <a href="http://www.aclweb.org/anthology/D14-1162">‚ÄúGlove: Global vectors for word representation.‚Äù</a> Proc. Conf. on empirical methods in natural language processing (EMNLP). 2014.</p>
:ET